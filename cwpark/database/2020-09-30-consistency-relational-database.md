# 관계형 데이터베이스의 일관성은 어떻게 유지될까? - 1편 미리 쓰기 로그



공개 키 암호화와 같이 온라이 거래에 핵심적인 기술을 꼽는다면, **데이터베이스** 가 있다.거의 모든 온라인 거래는 1970년대 이래 개발된 정교한 데이터베이스 기법을 이용해 처리된다. 데이터베이스는 **효율성** 과 **신뢰성** 두 가지를 위해 존재한다.

- 심각한 데이터 손실이 발생하는 문제가 발생하여도 데이터를 보전하는 알고리즘을 기반으로 신뢰성을 제공한다.
- 수천 명의 고객이 충돌이나 모순 없이 동시에 거래를 수행하는 알고리즘을 기반으로한 효율성을 제공한다.

이 두 가지 사안을 지키기 위한 알고리즘은 대표적으로 세 가지가 있다. **미리 쓰기 로그(write-ahead logging)** , **2단계 커밋(2-phase-commit)** , 그리고 **관계형 데이터베이스(releational database)** 가 있다.



데이터베이스에 일관성이 없다면 어떤일이 발생할까? 다음과 같이 구조화된 양식으로 저장된 테이블(table)이 친구 정보를 저장한다고 가정해보자.



| 이름     | 친구                       |
| -------- | -------------------------- |
| 스펀지밥 | 뚱이                       |
| 징징이   | 뚱이, 집게사장             |
| 뚱이     | 스펀지밥, 징징이, 집게사장 |
| 집게사장 | 징징이, 뚱이               |

이 테이블의 첫 두행에 약간의 변화를 주자.

| 이름     | 친구                |
| -------- | ------------------- |
| 스펀지밥 | 뚱이, <b>징징이</b> |
| 징징이   | 뚱이, 집게사장      |

첫 행을 보면, 스펀지밥과 징징이는 친구가 되었다. 그러나 두 번째 행에 따르면 징징이는 스펀지밥과 친구가 아니다. 

언제 이런일이 발생할까? 컴퓨터는 한 번에 데이터베이스의 한 행만을 업데이트할 수 있다. 일반적인 크기의 데이터베이스에서 두 행을 바꾼다면, 각각 두 번의 디스크 연산이 필요하다. 한 번의 디스크연산을 마치고 나머지 한 번의 디스크 연산을 남겨 놓은 시점에 컴퓨터가 충돌하면 어떻게 될까? 데이터베이스는 위의 표처럼 일관성 없는 상태로 변할 수 있다. 

이러한 유형의 불일치를 해결하기 위해 데이베이스 연구자들은 '트랜잭션'이라는 개념을 발명했다. 트랜잭션은 데이터베이스 변화의 집합을 의미한다. 데이터베이스 프로그래머는 "트랜잭션을 시작하라." 같은 명령을 발행하고 데이터베이스에 상호의존적인 변화를 가한 후 "트랜잭션을 종료하라."라는 명령으로 마무리한다. 트랜잭션 중 데이터베이스를 실행 중인 컴퓨터가 충돌을 일으킨다면 트랜잭션 시작 전과 같은 상태로 돌아갈 수 있다. 



## 할 일 목록 트릭

사람이 할 일을 작성하여 일을 체계적으로 해내듯이, 데이터베이스 또한 할 일 목록을 이용해 트랜잭션을 수행할 수 있다. 이를 더 어렵게 쓴 용어로는 **미리 쓰기 로그(write-ahead log)** 라는 것이 있다. 이 개념의 의미는 데이터베이스가 수행하려는 동작의 로그를 유지하는 것이다. 로그는 영구적 저장 장치에 저장된다. 그래서 로그에 있는 정보는 충돌과 재시작 후에도 살아남는다. 특정한 트랜잭션을 수행하기 전에 모든 동작은 로그에 기록되고 디스크에 저장된다. 다음의 예제를 통해 어떻게 미리 쓰기 로그를 사용하는지 살펴보자.



| 계좌 이름 | 계좌 유형 | 계좌 잔액 |
| --------- | --------- | --------- |
| 스펀지밥  | 당좌예금  | $800      |
| 스펀지밥  | 보통예금  | $300      |
| 징징이    | 당좌예금  | $150      |

> **미리 쓰기 로그**
>
> 1. 이체 트랜잭션 시작
> 2. 스펀지밥의 당좌예금 계좌 잔액을 $800에서 $600으로 변경
> 3. 스펀지밥의 보통예금 계좌 잔액을 $300에서 $500으로 변경
> 4. 이체 트랜잭션 종료

로그를 위와 같이 영구 저장 장치에 저장한 다음, 테이블에 변화를 주면 된다.

| 계좌 이름 | 계좌 유형 | 계좌 잔액 |
| --------- | --------- | --------- |
| 스펀지밥  | 당좌예금  | $600      |
| 스펀지밥  | 보통예금  | $500      |
| 징징이    | 당좌예금  | $150      |

트랜잭션 도중에 컴퓨터가 충돌하면 어떻게 할까? 스펀지밥의 당좌예금 계좌에서 돈이 빠져나갔지만, 보통 예금 계좌에 돈이 들어가기 전에 충돌이 났다고 가정하자. 컴퓨터는 재부팅하고 데이터베이스는 재시작하여 다음 정보를 하드 드라이브에서 찾는다.

| 계좌 이름 | 계좌 유형 | 계좌 잔액 |
| --------- | --------- | --------- |
| 스펀지밥  | 당좌예금  | $600      |
| 스펀지밥  | 보통예금  | $300      |
| 징징이    | 당좌예금  | $150      |

>**미리 쓰기 로그**
>
>1. 이체 트랜잭션 시작
>2. 스펀지밥의 당좌예금 계좌 잔액을 $800에서 $600으로 변경
>3. 스펀지밥의 보통예금 계좌 잔액을 $300에서 $500으로 변경
>4. 이체 트랜잭션 종료

데이터베이스는 어떤 동작이 수행됐고, 어떤 동작이 수행되지 않았는지 어떻게 구별할 수 있을까? 이 질문에 대한 대답은, *전혀 그럴 필요가 없다* 라는 것이다. 왜냐하면 데이터베이스 로그의 엔트리(각 번호)는 몇 번 수행되든 항상 같은 효과를 갖는다. 이를 멱등(idempotent)라고 한다.



트랜잭션을 이해하는 방법 중 하나는 **원자성(atomicity)** 를 이해하는 것이다. 원자적(atomic) 이라는 단어는 '쪼갤 수 없는'이란 뜻의 그리스어에서 유래했다. 트랜잭션이 쪼갤 수 없다는 의미는 무엇일까? 트랜잭션은 부분적으로 나눌 수 없다는 것이다. 즉, 트랜잭션은 전체가 성공하거나 실패한다면 시작조차 하지 않은 원래 상태여야 한다는 것이다. 수천 명의 고객이 동시에 데이터베이스에 접속하더라도 일관성과 효율성을 얻을 수 있는 것은 **준비 후 커밋 트릭** 이라는 방법을 사용했기 때문이다. (다음 편에 계속)

---

미래를 바꾼 아홉가지 알고리즘. 존 매코믹 지음. 민병교 옮김. 2012. 에이콘
